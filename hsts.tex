% Template appropriated from another paper. May contain lots of legacy commands.

%\documentclass[times,10pt,twocolumn]{article} 
\documentclass[conference]{./IEEEtran}
%\documentclass{./IEEEtran}
\usepackage{amsmath, amsthm, amssymb, latexsym}
%\usepackage{latex8}
%\usepackage{times}

\usepackage[hyphens]{url}
\usepackage{pgfplots}
\usepackage{array}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{color}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{tkz-graph}
\usepackage{bookmark}
%\usepackage[pdfstartview=FitH,colorlinks,linkcolor=blue,citecolor=blue]{hyperref}

\newcommand{\mysubsection}[1]{%
  \medskip
  \refstepcounter{subsection}%
    \everypar={%
      {\setbox0=\lastbox}% Remove the indentation
      \addcontentsline{toc}{subsection}{#1}%
      \textbf{{#1}.}
      \everypar={}%
    }%
  \ignorespaces
  % Dummy text in case there is no following text line (e.g. if the next thing is an itemize)
  %{\ }
  % TODO: MAKE SURE NO LINES ARE SWALLOWED BY THIS COMMAND.
}

\renewenvironment{leftbar}[1][\hsize]
{%
    \def\FrameCommand
    {%
        {\color{black}\vrule width 1pt}%
        \hspace{0pt}%must no space.
        \fboxsep=\FrameSep%
    }%
    \MakeFramed{\hsize#1\advance\hsize-\width\FrameRestore}%
}
{\endMakeFramed}


\newcommand{\algorithm}[2]{
%\begin{left bar}
\medskip
{\large \sc {#1}}
\medskip
\hrule
\smallskip
{#2}
\smallskip
\hrule
\medskip
%\end{leftbar}
}


\newcommand{\todo}[1]{\textcolor{red}{\textbf{[TODO: #1]}}}
\newcommand{\td}[2]{\textcolor{red}{\textbf{[TODO: {\it{#1}} #2]}}}

\newcommand{\site}[1]{\texttt{#1}}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\quotedcode}[1]{{\vspace{0.5em}\normalfont{\code{#1}\vspace{0.5em}}}}

\newcommand{\iSD}{{\code{includeSubDomains}}}
\newcommand{\ma}{{\code{max-age}}}

\newcommand{\genericsite}{example.com}
\newcommand{\h}{{\site{http://\genericsite}}}
\newcommand{\s}{{\site{https://\genericsite}}}
\newcommand{\hw}{{\site{http://www.\genericsite}}}
\newcommand{\sw}{{\site{https://www.\genericsite}}}


% Display all indices for development.
\newcommand{\draftonly}[1]{{\textcolor{orange}{#1}}}
%\renewcommand{\draftonly}[1]{}

% Theorem definitions
\theoremstyle{plain} 
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition} 

% For dev: page numbers with date.
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{Page \thepage\draftonly{\ -- Version: \today}}
\pagestyle{fancy}

\begin{document}


\title{The State of HSTS Deployment:\\A Survey and Common Pitfalls}

\author{}

% \author{
% Roy Frostig, Dan Boneh \\
% Stanford University \\
% \{rf,dabo\}@cs.stanford.edu \\
% \and
% Nicko van Someren \\
% Good Technology Inc. \\
% nicko@good.com
% }

\maketitle

% Page numbers on first page.
\thispagestyle{fancy}

\begin{abstract}
HSTS (HTTP Strict Transport Security) has gained significant browser and server adoption since reaching IETF proposed status. However, there are several important deployment challenges. A scan of top websites reveals that many HSTS sites have not properly configured the HSTS header, which still leaves them open to some attacks HSTS is meant to solve. We survey the current state of deployment and describe common mistakes and difficulties with HSTS configuration. We conclude with approaches for properly deploying HSTS as effectively as possible.
\end{abstract}

\section{Introduction}
\label{sec:intro}

\section{An Overview of HSTS}

HSTS (HTTP Strict Transport Security) is a header that a host sends to user agents to request heightened security for a domain. In particular, a conform any browser header that has received an HSTS header from \h will will automatically load future all requests to the site from \s instead. Thus, HSTS generally touted as a mechanism to ``transform insecure URI references\ldots into secure URI references''. However, it also also enforces strict security in related mechanisms, such as preventing mixed content and ``click-through'' certificate overrides\cite{rfc}.

There are three significantly distinct ways to send the HSTS header; these are described clearly in RFC 6797\cite{rfc}:

\quotation{\it
The HSTS header field below stipulates that the HSTS Policy is to
remain in effect for one year... and the policy applies only to the domain of the
HSTS Host issuing it:

\quotedcode{
Strict-Transport-Security: max-age=31536000
}

The HSTS header field below stipulates that the HSTS Policy is to
remain in effect for approximately six months and that the policy
applies to the domain of the issuing HSTS Host and all of its
subdomains:

\quotedcode{
Strict-Transport-Security: max-age=15768000 ; includeSubDomains
}

The HSTS header field below indicates that the UA must delete the
entire HSTS Policy associated with the HSTS Host that sent the header
field:

\quotedcode{
Strict-Transport-Security: max-age=0
}
}

The specification also states that the HSTS must only be sent and accepted over HTTPS, and that the \iSD~directive is ignored for domains when `max-age=0`.

In addition, all browsers currently supporting HSTS also ship with a ``pre-loaded'' list of known HSTS hosts.

\section{Browser Considerations}

\subsection{HSTS Browser Support}

As of September 29, 2013, HSTS is currently supported in the desktop versions of Chrome, Firefox, and Opera. It is not supported in Internet Explorer or Safari.\cite{support}

In addition, the mobile versions of Chrome (iOS and Android) and Firefox (Android) support HSTS like their desktop counterparts\cite{mdn}.

\subsection{Chromium Preload List}

The Chromium project maintains a list of sites in one of its source files\cite{sts-list}. A site owner can request their site to be included in this list to enforce a combination of several browser-side requirements including:

\begin{itemize}
\item \code{force-https} - enables HTTPS for a site by default (without expiration).
\item \iSD~- same as HSTS.
\item \code{pins} - specific pinned certificates.
\end{itemize}

Google Chrome and Chromium employ this list directly, enforcing the specified security measures.

Chrome considers HSTS to be part of the cache. The ``Empty the cache'' checkbox under ``Clear Browsing data'' wipes stored HSTS values.

\subsection{Opera}

Opera shares the WebKit-derived Blink engine with Chromium, so it exhibits the same HSTS behavior as Chrome.\footnote{Opera originally implemented support in Presto engine\cite{opera}, but Opera is closed-source, and \todo{does not provide explicit documentation about HSTS support since the Blink transition. It behaves like Chrome for preload sites according to the network console.}}

\subsection{Firefox Preload List}

Mozilla ``seeds'' the Firefox preload list by starting with the domains in the Chromium preload list, but performs its own filtering to keep the list fresh and observe the latest host settings. The Chromium list is processed a script\cite{firefox-script} that regularly run \cite{firefox-cron-script} by an automated build bot\cite{firefox-cron}, and the resulting preload list\cite{firefox-list} (along with the list of errors\cite{firefox-errors}) is committed to the \code{mozilla-central} repository.

A site is included in the Firefox preload list if the following hold:

\begin{itemize}
\item It is in the Chromium list (with \code{force-https}).
\item It sends an HSTS header.
\item The \code{max-age} sent is at least $10886400$ ($18$ weeks).
\end{itemize}

Firefox enforces HSTS for all sites in its preload list, which is hard-coded and compiled into the main binary.

The Firefox preload list also includes a boolean flag for \iSD. This flag is set to true if the script recorded \iSD~in the site's HSTS header (regardless of the Chromium list setting).

The Firefox preload list also includes an expiration time: each script run sets a timeout of $18$ weeks from the time it is run, after which Firefox will ignore it (i.e. sites can use HSTS normally, but the browser will no longer use the preload list to enforce HTTPS on first load for any sites)\cite{firefox-cron-expiration}. Since the release cycle shortens the time HSTS is useful in the browser to significantly less than $18$ weeks, the issue might be addressed in the future, any sites considering HSTS should check current Mozilla policies before selecting a {\ma}.

Firefox considers HSTS to be part of ``Site Preferences’’ in its ``Clear Recent History’’ feature.

\section{Current Deployment}

\subsection{Alexa Top $100000$ Sites}

We automatically surveyed the top $100000$ sites in the Alexa global rankings\cite{alexa} by making \code{GET} requests to four root URLs each:

\begin{itemize}
\item \h
\item \hw
\item \s
\item \sw
\end{itemize}

Although sites may use complicated HSTS mechanisms, we assume that front pages are a sufficient proxy of HSTS behavior. If sites are likely to go for maximum protection and/or simplest configuration, this is a fair assumption.

We recorded which sites:

\begin{itemize}
\item responded over HTTPS at all, either at {\s} or {\sw},
\item how many domains used HSTS with {\ma}$>0$ (and thus had any protection),
\item how may HTTPS sites used {\iSD}, and
\item how many domains used HSTS with a {\ma} of $0$.
\end{itemize}

We only considered HSTS headers that were well-formed and sent over HTTPS on either {\s} or {\sw}. Several technical and financial examples among the top few HSTS sites stand out, but we have not attempted to categorize which kinds of sites use HSTS. The tallies for top sites are summarized in table \ref{table:alexa} and figure \ref{fig:hsts}.

\begin{table}[h!]
\begin{center}
\begin{tabular}{|r|r|r|r|r|}
\hline
$\#$ top sites & HTTPS & HSTS & incl. sub. & \code{max-age=0} \\
\hline
10 & 8 & 1 & 0 & 1 \\
\hline
100 & 76 & 3 & 0 & 2 \\ 
\hline
1000 & 629 & 11 & 3 & 4 \\
\hline
10000 & 5402 & 56 & 11 & 10 \\
\hline
100000 & 46943 & 277 & 66 & 25 \\
\hline
\end{tabular}
\end{center}
\caption{HTTPS adoption vs. adoption of HSTS, HSTS with {\iSD}, and HSTS explicitly disabled.}
\label{table:alexa}
\end{table}%

These numbers were found by using a \code{python} script using the \code{scrapy}\cite{scrapy} library with a current Google Chrome user agent string \code{Mozilla/5.0 (Macintosh; Intel Mac OS X 10\_8\_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36}. All results are from early October 2013. Although we accepted any status code, we only considered initial responses (i.e. no redirects), since a primary goal is to secure the initial landing.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=70mm]{alexa_hsts.pdf}
\caption{HSTS adoption among the Alexa top 100000 sites.}
\label{fig:hsts}
\end{center}
\end{figure}

\subsection{The Alexa + Chromium HSTS Dataset}

For the rest of this paper, we will discuss sites from two sources:

\begin{itemize}
\item Alexa top $100000$ sites who send a valid HSTS header over HTTPS with {\ma}$ > 0$.
\item Sites from the Chromium HSTS Preload list with \code{force-https} set to \code{true}.
\end{itemize}

Since there is no registry of sites using HSTS (the Chromium preload is closest) and no ``typical’’ site using HSTS

\subsection{Common \code{max-age} Settings}

By far the most common {\ma} setting is a static value of $31536000$ seconds, which is roughly one year. This may be because the implementation examples on Wikipedia use this value\cite{wiki}, and it is the {\ma} of two (out of three) examples in RFC 6797\cite{rfc}. The majority of remaining sites are testing HSTS with very low values, ranging from seconds to days, although {\ma} values are as high as $20$ years (\code{twitter.com}).

As an interesting point, nearly every site serving HSTS on both {\s} and {\sw} sends the same {\ma} on both domains.

The {\ma} values group naturally into several buckets, which are displayed in figure \ref{fig:max-age} (including sites with {\ma} $0$ for comparison).

\begin{figure}[h!]
\begin{center}
\includegraphics[width=70mm]{max-age.pdf}
\caption{HSTS \code{max-age} settings of sites in the Alexa + Chromium dataset. (Each site is placed in the highest valid bucket.)}
\label{fig:max-age}
\end{center}
\end{figure}
 

\section{Common Deployment Patterns}

\todo{Clean up with final numbers}

Most sites redirect straight to 

\subsection{Redirect straight to \s}

A plurality of sites redirect straight to a final destination of \s, where they serve an HSTS header.

\subsection{Redirect straight to \sw}

Redirecting through {\s} with HSTS.

\subsection{Redirect to HTTPS}

\subsection{Redirect to \code{www}}

\section{Common Mistakes}
% \todo{Or, as Buzzfeed would call it: 3 Ways Your "Secure" Site is Horribly Broken.}

\subsection{Permanently Insecure Redirects}

A common pattern is to redirect to \sw~when the user types \site{\genericsite} into their browser. Assuming the parent domain is not on the preload list, the initial redirect is necessarily insecure on a fresh browser. If the site does not set an HSTS header for \s, then this insecure redirect occurs \emph{every time} the user types \site{\genericsite} into their browser.

This is mitigated the browser cache retains an entry for \site{\genericsite}. However, it is undesirable to rely on the cache for such a critical security guarantee, and the protection does not apply for any other pages/resources on \h~except the specific cached URL.

\subsection{Unprotected Subdomains}

Unless a site sets \iSD~on \s, neither of \s~or \sw~automatically set HSTS for each other. Assuming only one of these is visited by a normal user, the other will be unprotected.

\subsection{Accidental HSTS Expiration}

It is reasonable to send an HSTS header at \h~along with a $30x$ redirect to $\sw$. However, browsers may cache $301$ redirects  aggressively by default. The browser will send \h~visits directly to \sw, without visiting \s; thus, the browser will not see another HSTS header for \s, and HSTS will eventually expire once the {\ma} is reached. If the {\ma} is updated on the server, the browser will also not see the updated value.

Again, this reduces the security guarantee for HSTS to the cache for known URLs, and will eventually fail to protect other resources.

\subsection{Clerical Mistakes}

$30\%$ of HSTS sites in our survey also send an HSTS header over \h~or \hw. While an RFC-conforming browser is required to ignore this, RFC 6797\cite{rfc} also states that:

\begin{quotation}\it
An HSTS Host MUST NOT include the STS header field in HTTP responses conveyed over non-secure transport.
\end{quotation}

Sending the header over plain HTTP suggests an unfamiliarity with HSTS, apathy towards the specification, or inadequate control over redirect configuration.

In our scans, we also encountered various occasional mistakes, such as using a comma instead of a semicolon, sending an integer value without \code{max-age=}, including the \code{must-revalidate} directive (thus resembling a cache-control header), or removing the hyphen from \code{max-age}. A few sites, including \code{paypal.com}, also send two HSTS headers in the same request.

\section{Issues with Improving HSTS Configuration}

\subsection{Canonical Subdomain}

If the canonical domain for a site is \sw, the user may rarely load a page/resource from \s. This makes it more difficult to secure a fresh visit to \s, should the user visit it directly later. It also fails to protect any other subdomains.

\subsection{Implications of \iSD}
\label{includeSubDomains-issues}

In practice, using \iSD~may mot be straightforward at the top-level (\s) of an existing site because there is at least one subdomain that may break over HSTS. Possibilities for this include:

\begin{itemize}
\item Insecure resources will fail to load and break pages that worked over HTTPS without HSTS.
\item Such a large change is usually accompanied by increasing the scope of secure redirects (``\emph{if} we're going to do it, we may as well do it all at once''), which may break certain clients that rely on plain HTTP.\item The server for a subdomain is not configured to use HTTPS.
\item It may be impractical/expensive/risky to furnish every subdomain server with a valid CA-signed certificate.
\item The browser will prevent the user from using self-signed certificates for any subdomains.
\item The browser will enforce HTTPS for all subdomains even if there are other security measures in place (such as local testing or gating for a corporate network) that would otherwise allow the continued use of plain HTTP.
\end{itemize}

While it is worthwhile to address these issues and move towards more robust solutions that can operate under HSTS with \iSD, any site should be aware of these issues before considering HSTS a free panacea.

\section{Best Practice}

With regard to HSTS, a site should operate under the threat model that an attacker can run a man-in-the-middle attack over plain HTTP for any (sub)domain of the site, e.g. by exposing a victim to spoofed DNS entries. However, the attacker cannot intercept or modify valid HTTPS traffic over any of these subdomains.

Thus, it is desirable to protect as many subdomains as possible, as early as possible, by registering HSTS for them in the browser.

\subsection{Ideal Practice}


The strongest protection is to

\begin{itemize}
\item redirect every resource to HTTPS immediately
\end{itemize}

and serve well-formed  HSTS header:

\begin{itemize}
\item with every HTTPS request,
\item with a long \code{max-age} (18 weeks minimum, $1$ year recommended), and
\item with \iSD.
\end{itemize}

To be fully correct, the site must also:

\begin{itemize}
\item never send an HSTS header over plain HTTP.
\end{itemize}

This protects all future requests to the site or any of its subdomains. If the canonical site is \s, any requests to the site will automatically extend the expiration date (including for subdomains).

In addition, once a site is committed to HSTS, it should:
\begin{itemize}
\item be included in the browser preload lists.
\end{itemize}

Any security-conscious site should strive to all of take these steps, if possible. In case this is initially impractical

\subsection{Send an HSTS header whenever possible}

It is advisable to send an HSTS header on any request sent from a (sub)domain only intended to be accessed over HTTPS. This ensures that HSTS is enabled on every subdomain as early as possible, without depending on other sub/superdomains.

In addition, every visit extends the expiration of HSTS.

\subsection{Send the most secure settings possible}

Every site should aim to ramp up its \code{max-age} as high as possible (at least to the popular default of $6$ or $12$ months).

As advocated in section $14.4$ of RFC 6797\cite{rfc}, a site should aim to send \code{includeSubdomains} whenever possible. Although section \ref{includeSubDomains-issues} discusses issues with \iSD~for \s, it is usually safe to send \iSD~on any particular subdomain, including \sw.

\subsection{Redirect Immediately and Securely}

Unless legacy use cases require plain HTTP support, every request should be redirected to HTTPS (using a $30x$ status) before any content is served.

Any redirect served over HTTPS should include an HSTS header, to ensure that the redirect is fully secured in the future.

A site should redirect HTTP requests to the HTTPS version the request before performing other canonicalization steps like adding/removing \code{www}. This ensures that HSTS will be applied to future redirects on the same domain.

In case all the redirect URLS and final destinations of a site are protected using \iSD~at the destination, a two-hop redirect and a separate HSTS setting for the redirect (sub)domain may seem redundant. However, the first redirect will be eliminated once HSTS in place, and continues to protect the redirect in case \iSD~needs to be removed.

\subsection{Securing \s~from a subdomain}

If most pages are served from a subdomain like \sw, securing the entire domain requires an additional step. A simple solution is to make a request to an uncached HSTS-serving resource on \s, such as a $1$-pixel \code{<img>}. This is best done using a cache-control header, but simple cache-busting tricks work equally well.

This uncached-resource approach works in all current HSTS browsers. In case a site would like to minimize resource fetches, the particular HSTS resource can:
\begin{itemize}
\item send a short-lived \code{cache-control} header for the resource instead, and/or
\item be configured not redirect from \s~to \sw.
\end{itemize}

Such a solution is being used successfully in practice, e.g. by \site{https://www.icloud.com}.

\subsection{Ensure that incoming visits are secure}

Although a site should serve a plain HTTP request once if it is received, it is useful to protect them from ever doing so, by making sure they are likely to visit over HTTPS first (and are protected from future insecure visits if HSTS is enabled).

Once a site is committed to HTTPS, it should ensure that all links on the website are updated to HTTPS (or protocol-relative URLs) and that automatically generated links (e.g. shortened URLs, ``copy link’’ buttons, API-generated links) are generated with \code{https://}. This will help ensure that future incoming visits are secured immediately.


\section{Conclusion}

We described the current state of HSTS in the specification and browser implementation. Based on this, we surveyed top sites and found a few of them send an HSTS header, but many of them do not secure as many of their (sub)domains as they should -- leaving them open to many attacks that HSTS was meant to mitigate. In particular found that canonicalization redirects often stay insecure even if HSTS is used at the final page. We briefly discussed that sites should be aware of when using {\iSD}, and concluded with concrete suggestions to improve HSTS deployment. These suggestions mostly center around selecting the most secure options available, and ensuring that the browser receives them for the desired domain -- either during a redirect or using a resource load on the final destination.

These results remind us that HSTS, while effective, should not be treated like snake oil. Sites must be aware of HSTS details, and we hope this paper provides many of the details helpful for making the correct choices about initial and continued deployment.

We note that most of the issues stem from the fact that HSTS can only protect the current domain and not subdomains. Our survey shows that sites are likely to end up with unintentional security weaknesses given the currently available information. Thus, we hope that future work will either address related domains at the specification level, or that the issues and solutions identified in this paper are clearly available to sites considering HSTS -- leading to a more secure web.


\bibliographystyle{./IEEEtran}
\bibliography{hsts}

\end{document}
